# Синтаксис поисковых выражений

Фильтр поиска Seq можно использовать для поиска событий, содержащих определённый текст, или имеющих свойства с конкретными значениями.

Если вы только начинаете работать с Seq, вы обнаружите, что комбинация текстового поиска (просто введите то, что ищете) и фильтрации с помощью значков _галочка_ и _крест_ рядом со свойствами события охватит большинство ваших потребностей и также покажет вам основы синтаксиса фильтра.

Когда вы будете готовы узнать больше, эта страница познакомит вас с полным синтаксисом, чтобы вы могли раскрыть полный потенциал возможностей фильтрации Seq. Организация построена примерно вокруг нескольких основных тем:

- **[Текст](#текст)** - поиск строк в сообщениях
- **[Свойства и операторы](#свойства-и-операторы)** - сравнения, полезные при работе со структурированными данными событий
- **[Типы событий](#типы-событий)**
- **[Работа с датами и временем](#работа-с-датами-и-временем)**
- **[Коллекции](#коллекции)** - сопоставление элементов в свойствах со значениями коллекций

Дополнительная справка описывает [встроенные свойства](https://datalust.co/docs/built-in-properties-and-functions) и [функции](https://datalust.co/docs/scalar-functions), которые можно использовать в фильтрах.

## Текст

Самые простые текстовые запросы в Seq — это текстовые фрагменты, вводимые непосредственно в строку фильтра:

Когда Seq определяет, что фильтр не является допустимым выражением, он ищет в сообщениях журнала полную строку текста.

Чтобы заставить Seq искать текст, даже если этот текст оказывается допустимым фильтром, заключите его в `"двойные кавычки"`:

```csharp
"logged on as contact AUTO-3af7-dadc93"
```

Текстовые фрагменты в _двойных кавычках_ используют те же последовательности экранирования на основе обратного слэша `\`, что и C# и JavaScript.

> Одиночные и двойные кавычки
>
> Хотя текстовые фрагменты заключаются в `"двойные кавычки"`, фильтры Seq и [SQL-подобные запросы](https://datalust.co/docs/sql-queries) используют строковые литералы в стиле SQL с `'одиночными кавычками'`, например в выражении `Environment = 'Test'`.

Поиск на основе текстовых фрагментов не чувствителен к регистру.

### `and`, `or`, `not`

Seq предоставляет знакомые логические операторы, включая `and` (логическое _и_), `or` (логическое _или_) и `not` (логическое отрицание/_не_). Их можно применять непосредственно к текстовым выражениям для формирования более сложных запросов:

```sql
"logged on" and ("HIS-e531-5eb5e3" or "AUTO-3af7-dadc93")
```

### Регулярные выражения

Поддерживается полный поиск по регулярным выражениям. Регулярные выражения разделены косыми чертами. Для сопоставления «hello, world» и «hold»:

```javascript
/h.*d/
```

Обратные слэши можно использовать для экранирования встроенной косой черты:

```javascript
/https:\/\/datalust\.co/
```

## Свойства и операторы

Структурированные события обычно поставляются с богатым набором свойств, которые можно использовать для фильтрации. Разворачивание события покажет доступные свойства, а щелчок по зелёной _галочке_ рядом с названием свойства предоставит некоторые базовые параметры фильтрации:

Это полезный способ ознакомиться с операторами, которые можно применять к свойствам события. _Поиск_ создаст выражение фильтра типа:

```csharp
ProductId = 'product-32'
```

> _Везде_, где вы видите строковые литералы в Seq, также можно использовать регулярное выражение — так что `Application = /P.*l/` работает как ожидается и здесь.

### Список доступных свойств

Встроенный SQL-запрос _Доступные свойства_, доступный в нижней правой части строки сигнала, покажет доступные свойства всех событий, соответствующих текущему фильтру.

### Основные сравнения

Seq поддерживает типичный набор операторов сравнения: `=`, `<>`, `<`, `<=`, `>`, `>=` означают _равно_, _не равно_, _меньше_, _меньше или равно_, _больше_ и _больше или равно_.

Строки также можно сравнивать с использованием SQL оператора `like`; используются подстановочные знаки `%` (любое количество символов) и `_` (один символ):

```sql
Application like 'P%'
```

Сравнения, включающие `=` и `like`, чувствительны к регистру. Для сопоставления без учёта регистра добавьте модификатор `ci`:

```sql
Application like 'P%' ci
```

Модификатор `ci` работает везде в Seq, например `Application = 'Test'` чувствителен к регистру, тогда как `Application = 'test' ci` будет соответствовать `TEST`, `test`, `TeSt` и так далее.

Seq также распознаёт функционально-стилевые операторы, вызываемые как `Name(arg0, arg1, ...)`. Для свойств строкового типа, например, полезны `StartsWith()`, `EndsWith()` и `Contains()`:

```csharp
StartsWith(Application, 'P')
```

Полный список встроенных функций приведен в справке [Встроенные свойства и функции](https://datalust.co/docs/built-in-properties-and-functions).

### Вложенные свойства

Seq использует синтаксис с точкой `.` для запроса вложенных свойств сложных объектов. Например, `Cart.Total` ссылается на свойство `Total` объекта в свойстве `Cart`.

### `IN` выражения

Значение свойства можно сопоставить с несколькими альтернативами с использованием `IN`:

```sql
Application in ['Web', 'API']
```

### Условные выражения

Seq поддерживает условные выражения с использованием синтаксиса `if`/`then`/`else`:

```sql
if Quantity = 0 then 'None' else 'Plenty'
```

Условные выражения можно связывать в цепь:

```sql
if Quantity = 0 then 'None' else if Quantity < 20 'Some' else 'Plenty'
```

## Типы событий

Возможно, самое полезное, но редко замечаемое преимущество структурированного события — это полнофункциональное понятие типа события.

При анализе традиционного текстового журнала нет конкретной связи между сообщениями:

```
Pre-discount tax total calculated at $0.14
Pre-discount tax total calculated at $5.20
Customer paid using CreditCard
```

С точки зрения инструментов каждый может быть уникальным блоком произвольного текста.

В структурированном событии от Serilog _шаблон сообщения_, переданный функции логирования, сохраняется вместе с событием. Поскольку первые два происходят из шаблона:

```csharp
"Pre-discount tax total calculated at {TaxAmount}"
```

Тогда как третий происходит из:

```csharp
"Customer paid using {PaymentMethod}"
```

Мы можем использовать эту информацию для однозначного поиска или исключения любого вида события. Работа с шаблонами сообщений многословна, поэтому Seq создает 32-битный хэш шаблона сообщения и делает это доступным в встроенном свойстве `@EventType`.

Например, `"Pre-discount tax total calculated at {TaxAmount}"` → `0xA26D9943`, тогда как `"Customer paid using {PaymentMethod}"` → `0x4A310040`.

> Тип события можно просмотреть, щелкнув событие для его разворачивания. Раскрывающееся меню _Тип_ отображает тип события.

Найти все события определённого типа легко:

```csharp
@EventType = 0x4A310040
```

## Работа с датами и временем

Чтобы выбрать события в заданном диапазоне дат, щелчок по кнопке «Показать или скрыть гистограмму» прямо под поле поиска обеспечивает быструю и простую навигацию на основе времени:

Для более сложных операций на основе времени можно использовать встроенное свойство `@Timestamp` и функции `DateTime()`.

В запросе вы можете написать:

```sql
@Timestamp > DateTime('2014-01-03')
```

Это сравнивает `@Timestamp` события с литералом **UTC**. Для указания часового пояса используйте синтаксис `+`/`-`:

```sql
@Timestamp > DateTime('2014-01-03 +10')
```

Функция `DateTime()` может конструировать правильные объекты даты и времени из ISO 8601 и различных других форматированных свойств событий:

```csharp
DateTime(FinishedAt) > DateTime(ExipresAt)
```

Длительности, отформатированные в синтаксис `d.HH:mm:ss.fff`, можно манипулировать в запросах с помощью функции преобразования `TotalMilliseconds()`:

```csharp
TotalMilliseconds(Elapsed) > 3000
```

Для полного описания функций манипулирования датой и временем Seq см. [Работа с датами и временем](https://datalust.co/docs/working-with-dates-and-times).

## Коллекции

Не редко структурированные события содержат свойства, которые являются коллекциями. Например, мы можем логировать события типа:

```csharp
Log.Information("Updated {ProductId} with categories {Categories}", "product-32", new[] { "drinks", "coffees" });
```

Результатом чего являются события типа:

В этом примере каждое событие содержит коллекцию нулевого или большего количества строк в свойстве `Categories`.

### Индексирование по номерам

Как и ожидается, поддерживается индексирование по номерам:

```sql
Categories[0] = 'drinks'
```

### Фильтры с подстановочными знаками

Чтобы найти события с конкретным элементом в коллекции `Categories`, напишите фильтр как при проверке одного элемента, используя подстановочный знак вместо индекса, который обычно там появляется:

```sql
Categories[?] = 'drinks'
```

Подстановочный знак в виде вопросительного знака `?` соответствует _любому_ элементу коллекции, тогда как подстановочный знак в виде звёздочки `*` соответствует только если _все_ элементы удовлетворяют условию.

Подстановочные знаки работают в любом сравнении, где одна сторона — это путь свойства (включая индексаторы и точечные подсвойства). Поддерживаются несколько подстановочных знаков вдоль пути.

Вы можете написать следующее выражение для поиска вопросов, где все ответы — `'Yes!'`:

```sql
Answers[*].Content = 'Yes!'
```

## Шпаргалка

Нужна удобная справка, чтобы держать её на столе? Мы собрали шпаргалку с основами фильтрации. [Загрузите PDF отсюда](https://github.com/datalust/seq-cheat-sheets).
Я перевёл документацию по синтаксису поисковых выражений Seq на русский язык, сохраняя всю структуру и форматирование markdown-файла.

Перевод включает:
- Все основные разделы и подразделы с правильной иерархией заголовков
- Примеры кода (они остаются без изменений, как и положено)
- Блоки цитирования и примечания
- Все ссылки и ссылки на справочные материалы
- Синтаксис форматирования (код, кавычки, выделение)

Переведённый документ готов к использованию и полностью сохраняет структуру оригинала.
